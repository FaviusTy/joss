// Copyright (c) 2021 Quantitative Risk Solutions PLT (201604001668)
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
const JOSS=function(){"use strict";const l=J(),R={Object:k,Array:k,Map:k,Set:k,DataView:f,Int8Array:f,Uint8Array:f,Uint8ClampedArray:f,Int16Array:f,Uint16Array:f,Int32Array:f,Uint32Array:f,Float32Array:f,Float64Array:f,BigInt64Array:f,BigUint64Array:f,Date:N,RegExp:S,ArrayBuffer:i,SharedArrayBuffer:i,Boolean:x,Number:s,BigInt:t,String:i},a={hole:new Error("Encountered a hole in a sparse array"),ended:new Error("The serialized bytestream ended before the deserialization could complete successfully."),unused:new Error("The deserialization completed before the end of the serialized bytestream."),exceeded:new Error("The serialized bytestream exceeded the maximum acceptable length."),malformed:new Error("The serialized bytestream contained malformed byte sequences."),property:new Error("Encountered an undefined property of a collection."),collection:new Error("Encountered a collection in streaming mode.")};return a.ended.name="ERR_ENDED",a.unused.name="ERR_UNUSED",a.exceeded.name="ERR_EXCEEDED",a.malformed.name="ERR_MALFORMED",Function.prototype.name===void 0&&Object.defineProperty(Function.prototype,"name",{get:function(){return this.toString().match(/^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^\(\s\/]*)\s*/)[1]}}),Uint8Array.of=Uint8Array.of||function(){const a=new this(arguments.length);return a.set(Array.prototype.slice.call(arguments)),a},Uint8Array.from=Uint8Array.from||function(){const a=new this(arguments[0].length);return a.set(arguments[0]),a},Uint8Array.prototype.forEach=Uint8Array.prototype.forEach||Array.prototype.forEach,{serialize:P,deserialize:O,serializable:Q,deserializable:G,deserializing:H};function P(c,b){const a={};if(b===void 0)b={};else if(typeof b!="object")throw new TypeError("The options parameter must be an object.");if(b.hasOwnProperty("endian")===!1)a.endian=l;else if(b.endian==="LE"||b.endian==="BE")a.endian=b.endian;else throw new RangeError('The endian option must be either "LE" or "BE".');return a.bytes=[],a.length=0,a.record=new Map,a.method="static",e(a,c),q(a.bytes,a.length)}function e(a,c){switch(typeof c){case"object":if(c!==null){const d=c.constructor.name,e=R[d];return e!==void 0?a.record.has(c)===!1?(a.record.set(c,a.length),e(a,c,d)):z(a,c):b(a,Uint8Array.of(13))}else return b(a,Uint8Array.of(0));case"undefined":return b(a,Uint8Array.of(1));case"boolean":return x(a,c);case"number":return s(a,c);case"bigint":return t(a,c);case"string":return i(a,c);default:b(a,Uint8Array.of(13))}}function x(a,c,d){d===void 0?c===!0?b(a,Uint8Array.of(2)):b(a,Uint8Array.of(4)):c.valueOf()===!0?b(a,Uint8Array.of(3)):b(a,Uint8Array.of(5))}function s(d,g,h){let f,e,a;if(f=1<<5,h===void 0)if(a=g,isFinite(a));else return a===1/0?b(d,Uint8Array.of(6)):a===-(1/0)?b(d,Uint8Array.of(8)):b(d,Uint8Array.of(10));else if(a=g.valueOf(),isFinite(a))f|=1<<4;else return a===1/0?b(d,Uint8Array.of(7)):a===-(1/0)?b(d,Uint8Array.of(9)):b(d,Uint8Array.of(11));Math.floor(a)===a&&Math.abs(a)<=Number.MAX_SAFE_INTEGER?((a<0||a===0&&1/a===-(1/0))&&(f|=1<<3),e=c(Math.abs(a))):(e=new Uint8Array(new ArrayBuffer(8)),new DataView(e.buffer,e.byteOffset,e.byteOffset+e.length).setFloat64(0,a,!0)),b(d,Uint8Array.of(f|e.length-1)),b(d,e)}function t(f,g,i){let d,e,a;d=2<<5,i===void 0?a=g:(a=g.valueOf(),d|=1<<4),a>=0?e=w(a):(d|=1<<3,e=w(-a));const h=c(e.length);b(f,Uint8Array.of(d|h.length-1)),b(f,h),b(f,e)}function i(g,e,f,i,j){let d,a;d=3<<5,f===void 0?a=v(e):f==="String"?(d|=1<<3,a=v(e.valueOf())):(f==="ArrayBuffer"?d|=2<<3:d|=3<<3,a=new Uint8Array(e,i||0,j||e.byteLength));const h=c(a.length);b(g,Uint8Array.of(d|h.length-1)),b(g,h),b(g,a)}function k(d,f,h){if(d.method==="stream")throw a.collection;let g;if(g=4<<5,h==="Array"){const a=c(f.length),h=u(f);if(h.nslot!==void 0){g=5<<5;const i=h.nslot,j=c(i);b(d,Uint8Array.of(g|0<<4|a.length-1<<2|j.length-1)),b(d,a),b(d,j);for(let a=0;a<i;a+=1)f.hasOwnProperty(a)?e(d,f[a]):b(d,Uint8Array.of(12))}else if(h.nelement!==void 0){g=5<<5;const i=c(h.nelement);b(d,Uint8Array.of(g|1<<4|a.length-1<<2|i.length-1)),b(d,a),b(d,i),f.forEach(function(a,b){e(d,b),e(d,a)})}else{const h=c(f.length);b(d,Uint8Array.of(g|a.length-1)),b(d,a),f.forEach(function(a){e(d,a)})}}else if(h==="Object"){{const a=c(Object.keys(f).length);b(d,Uint8Array.of(g|1<<3|a.length-1)),b(d,a);for(let a in f)f.hasOwnProperty(a)&&(e(d,a),e(d,f[a]))}}else if(h==="Map"){const a=c(f.size);b(d,Uint8Array.of(g|2<<3|a.length-1)),b(d,a),f.forEach(function(a,b){e(d,b),e(d,a)})}else{const a=c(f.size);b(d,Uint8Array.of(g|3<<3|a.length-1)),b(d,a),f.forEach(function(a){e(d,a)})}}function f(d,c,h){let e,a,f,g;if(e=6<<5,d.endian==="BE"&&(e|=1<<4),d.endian!==l&&c.BYTES_PER_ELEMENT>1){switch(a=c.buffer.slice(c.byteOffset,c.byteOffset+c.byteLength),c.BYTES_PER_ELEMENT){case 2:a=n(a);break;case 4:a=j(a);break;case 8:a=m(a);break}f=0,g=a.byteLength}else a=c.buffer,f=c.byteOffset,g=c.byteLength;const k=["DataView","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];b(d,Uint8Array.of(e|k.indexOf(h))),d.record.has(a)===!1?(d.record.set(a,d.length),i(d,a,a.constructor.name,f,g)):z(d,a)}function N(a,c){b(a,Uint8Array.of(14)),e(a,c.valueOf())}function S(a,c){b(a,Uint8Array.of(15)),e(a,c.toString())}function z(a,c){b(a,Uint8Array.of(29)),s(a,a.record.get(c))}function c(a){const b=[];while(a>255)b.push(a&255),a=Math.floor(a/256);return b.push(a),Uint8Array.from(b)}function w(a){const b=[],d=BigInt(8),c=BigInt(255);while(a>c)b.push(Number(a&c)),a=a>>d;return b.push(Number(a)),Uint8Array.from(b)}function v(a){try{return(new TextEncoder).encode(a)}catch(e){let c=0;const b=[],d=a.length;while(c<d){let d=a.charCodeAt(c++);if(d<=127)b.push(d);else if(d<=2047)b.push(d>>6&31|192),b.push(d&63|128);else if(d<=55295||d>=57344&&d<=65535)b.push(d>>12&15|224),b.push(d>>6&63|128),b.push(d&63|128);else{const e=d,f=a.charCodeAt(c++);if(e<55296||e>56319)continue;if(f<56320||f>57343)continue;d=(e&1023)<<10|f&1023,d+=65536,b.push(d>>18&7|240),b.push(d>>12&63|128),b.push(d>>6&63|128),b.push(d&63|128)}}return Uint8Array.from(b)}}function Q(o,g){const d={};if(g===void 0)g={};else if(typeof g!="object")throw new TypeError("The options parameter must be an object.");if(g.hasOwnProperty("endian")===!1)d.endian=l;else if(g.endian==="LE"||g.endian==="BE")d.endian=g.endian;else throw new RangeError('The endian option must be either "LE" or "BE".');d.length=0,d.record=new Map,d.method="stream";const h=[],f=[],k=[],m=Symbol(),i=Symbol(),j=Symbol();return new ReadableStream({start:p,pull:r});function p(a){h.push(0),f.push({root:o}),k.push(n(f[0]))}function r(l){let o=0,g=f.length-1;for(d.bytes=[];o<16384&&g>=0;){const r=d.length,p=h[g],l=f[g],s=k[g],q=s.next();if(p===0){let a;a=4<<5;const e=l.constructor.name;if(e==="Array"){const e=c(l.length);if(l.hasOwnProperty(i)){a=5<<5;const f=c(l[i]);b(d,Uint8Array.of(a|0<<4|e.length-1<<2|f.length-1)),b(d,e),b(d,f)}else if(l.hasOwnProperty(j)){a=5<<5;const f=c(l[j]);b(d,Uint8Array.of(a|1<<4|e.length-1<<2|f.length-1)),b(d,e),b(d,f)}else{const f=c(l.length);b(d,Uint8Array.of(a|e.length-1)),b(d,e)}}else if(e==="Object"&&g!==0){const e=c(l[m]);b(d,Uint8Array.of(a|1<<3|e.length-1)),b(d,e)}else if(e==="Map"){const e=c(l.size);b(d,Uint8Array.of(a|2<<3|e.length-1)),b(d,e)}else if(e==="Set"){const e=c(l.size);b(d,Uint8Array.of(a|3<<3|e.length-1)),b(d,e)}}if(q.done===!1){if(p!==2){const b=q.value,c=l.constructor.name;if(c==="Array"&&l.hasOwnProperty(j))e(d,b);else if(c==="Object"&&g!==0)e(d,b);else if(c==="Map")try{e(d,b)}catch(c){if(c===a.collection)h.push(0),f.push(b),k.push(n(b));else throw c}h[g]=2}else if(p===2){const c=q.value;if(c!==a.hole)try{e(d,c)}catch(b){if(b===a.collection)h.push(0),f.push(c),k.push(n(c));else throw b}else l.hasOwnProperty(i)&&b(d,Uint8Array.of(12));h[g]=1}}else delete l[j],delete l[i],delete l[m],h.pop(),f.pop(),k.pop();o+=d.length-r,g=f.length-1}d.bytes.length!==0?l.enqueue(q(d.bytes)):g>=0?this.pull(l):l.close()}function n(b){let c,g,f,d;g="key";const e=b.constructor.name;if(e==="Array"){d=b.keys();const a=u(b);a.nslot!==void 0?Object.defineProperty(b,i,{configurable:!0,value:a.nslot}):a.nelement!==void 0&&Object.defineProperty(b,j,{configurable:!0,value:a.nelement})}else e==="Object"?(d=Object.keys(b),Object.defineProperty(b,m,{configurable:!0,value:d.length}),f=-1):(e==="Map"||e==="Set")&&(d=b.keys());return{next:h};function h(){if(g==="key")if(g="value",f===void 0){let a=d.next();if(b.hasOwnProperty(j))while(b.hasOwnProperty(a.value)===!1&&a.done===!1)a=d.next();return a.done===!1?(c=a.value,b.hasOwnProperty(i)&&c>=b[i])?{value:void 0,done:!0}:{value:c,done:!1}:{value:void 0,done:!0}}else return f+=1,d[f]!==void 0?(c=d[f],{value:c,done:!1}):{value:void 0,done:!0};else if(g="key",e==="Array")return b.hasOwnProperty(c)?{value:b[c],done:!1}:{value:a.hole,done:!1};else if(e==="Object")return{value:b[c],done:!1};else if(e==="Map")return{value:b.get(c),done:!1};else if(e==="Set")return{value:c,done:!1}}}}function O(c){if(typeof c!="object"||c.constructor.name!=="Uint8Array")throw new TypeError("The bytes parameter must be a Uint8Array.");const b={};b.map=new Map,b.bytes=c,b.cursor=0,b.offset=0,b.method="static";const e=d(b);if(b.cursor!==b.bytes.length)throw a.unused;return e}function d(b){const c=b.bytes[b.cursor];if(c===void 0)throw a.ended;if(c<=13){let d;switch(b.cursor++,b.offset++,c){case 0:return null;case 1:return void 0;break;case 2:return!0;case 3:d=new Boolean(!0);break;case 4:return!1;case 5:d=new Boolean(!1);break;case 6:return 1/0;case 7:d=new Number(1/0);break;case 8:return-(1/0);case 9:d=new Number(-(1/0));break;case 10:return NaN;case 11:d=new Number(NaN);break;case 12:return a.hole;case 13:return new ReferenceError}return b.map.set(b.offset-1,d),d}if(c<=31)switch(c){case 14:return D(b);case 15:return B(b);case 29:return C(b);default:throw a.malformed}else switch(c>>5){case 1:return M(b);case 2:return L(b);case 3:return I(b);case 4:return U(b);case 5:return F(b);case 6:return E(b);case 7:throw a.malformed}}function M(b){let c,d=b.cursor;const f=b.bytes[d++],e=(f&7)+1;if(d+e>b.bytes.length)throw a.ended;if(e<8){if(e===7&&b.bytes[d+6]>31)throw a.malformed;c=g(b.bytes.subarray(d,d+=e)),(f>>3&1)===1&&(c*=-1)}else{const a=b.bytes.subarray(d,d+=e);c=new DataView(a.buffer,a.byteOffset,a.length).getFloat64(0,!0)}return(f>>4&1)===1&&(c=new Number(c),b.map.set(b.offset,c)),b.cursor+=e+1,b.offset+=e+1,c}function L(b){let d,c=b.cursor;const h=b.bytes[c++],e=(h&7)+1;if(c+e>b.bytes.length)throw a.ended;const f=g(b.bytes.subarray(c,c+=e));if(c+f>b.bytes.length)throw a.ended;return d=A(b.bytes.subarray(c,c+=f)),(h>>3&1)===1&&(d*=BigInt(-1)),(h>>4&1)===1&&(d=new Object(d),b.map.set(b.offset,d)),b.cursor+=e+f+1,b.offset+=e+f+1,d}function I(b){let d,c=b.cursor;const h=b.bytes[c++],f=(h&7)+1;if(c+f>b.bytes.length)throw a.ended;const e=g(b.bytes.subarray(c,c+=f));if(c+e>b.bytes.length)throw a.ended;switch(h>>3&3){case 0:d=y(b.bytes,c,c+=e);break;case 1:d=new String(y(b.bytes,c,c+=e)),b.map.set(b.offset,d);break;case 2:d=new ArrayBuffer(e),b.map.set(b.offset,d),new Uint8Array(d).set(b.bytes.subarray(c,c+=e));break;case 3:d=new SharedArrayBuffer(e),b.map.set(b.offset,d),new Uint8Array(d).set(b.bytes.subarray(c,c+=e))}return b.cursor+=f+e+1,b.offset+=f+e+1,d}function U(b){if(b.method==="stream")throw a.collection;let c,f=b.cursor;const j=b.bytes[f++],k=b.bytes.length,e=(j&7)+1;if(f+e>k)throw a.ended;const i=g(b.bytes.subarray(f,f+=e));switch(j>>3&3){case 0:c=[],b.map.set(b.offset,c),b.cursor+=e+1,b.offset+=e+1;for(let e=0;e<i;e+=1){if(h(b))throw a.malformed;c.push(d(b))}return c;case 1:c={},b.map.set(b.offset,c),b.cursor+=e+1,b.offset+=e+1;for(let e=0;e<i;e+=1){if(o(b)===!1)throw a.malformed;const f=d(b);if(c.hasOwnProperty(f))throw a.malformed;if(h(b))throw a.malformed;c[f]=d(b)}return c;case 2:c=new Map,b.map.set(b.offset,c),b.cursor+=e+1,b.offset+=e+1;for(let e=0;e<i;e+=1){const f=d(b);if(c.has(f))throw a.malformed;if(h(b))throw a.malformed;c.set(f,d(b))}return c;case 3:c=new Set,b.map.set(b.offset,c),b.cursor+=e+1,b.offset+=e+1;for(let e=0;e<i;e+=1){if(h(b))throw a.malformed;const f=d(b);if(c.has(f))throw a.malformed;c.add(f)}return c}}function F(b){if(b.method==="stream")throw a.collection;let c=b.cursor;const j=b.bytes[c++],k=b.bytes.length,f=(j>>2&3)+1;if(c+f>k)throw a.ended;const l=g(b.bytes.subarray(c,c+=f)),e=new Array(l),i=(j&3)+1;if(c+i>k)throw a.ended;const m=g(b.bytes.subarray(c,c+=i));if(b.map.set(b.offset,e),b.cursor+=f+i+1,b.offset+=f+i+1,(j>>4&1)===0){for(let c=0;c<m;c+=1){const f=d(b);f!==a.hole&&(e[c]=f)}return e}for(let f=0;f<m;f+=1){if(r(b)===!1)throw a.malformed;const c=d(b);if(c>=l)throw a.malformed;if(e.hasOwnProperty(c))throw a.malformed;if(h(b))throw a.malformed;e[c]=d(b)}return e}function E(b){const f=b.offset,e=b.bytes[b.cursor],c=l!==(e>>4&1?"BE":"LE"),g=e&15;b.cursor++,b.offset++;try{let h;if(T(b)===!1)throw a.malformed;const e=d(b);switch(g){case 0:h=new DataView(e);break;case 1:h=new Int8Array(e);break;case 2:h=new Uint8Array(e);break;case 3:h=new Uint8ClampedArray(e);break;case 4:h=c?new Int16Array(n(e.slice())):new Int16Array(e);break;case 5:h=c?new Uint16Array(n(e.slice())):new Uint16Array(e);break;case 6:h=c?new Int32Array(j(e.slice())):new Int32Array(e);break;case 7:h=c?new Uint32Array(j(e.slice())):new Uint32Array(e);break;case 8:h=c?new Float32Array(j(e.slice())):new Float32Array(e);break;case 9:h=c?new Float64Array(m(e.slice())):new Float64Array(e);break;case 10:h=c?new BigInt64Array(m(e.slice())):new BigInt64Array(e);break;case 11:h=c?new BigUint64Array(m(e.slice())):new BigUint64Array(e);break;default:throw a.malformed}return b.map.set(f,h),h}catch(c){throw c===a.ended?(b.cursor--,b.offset--,c):c}}function D(b){const c=b.offset;b.cursor++,b.offset++;try{if(K(b)===!1)throw a.malformed;const e=new Date(d(b));return b.map.set(c,e),e}catch(c){throw c===a.ended?(b.cursor--,b.offset--,c):c}}function B(b){const c=b.offset;b.cursor++,b.offset++;try{if(o(b)===!1)throw a.malformed;const e=d(b),f=e.lastIndexOf("/");if(e[0]!=="/"||f<=0)throw a.malformed;const g=new RegExp(e.slice(1,f),e.slice(f+1));return b.map.set(c,g),g}catch(c){throw c===a.ended?(b.cursor--,b.offset--,c):c}}function C(b){b.cursor++,b.offset++;try{if(r(b)===!1)throw a.malformed;const c=d(b);if(b.map.has(c)===!1)throw a.malformed;return b.map.get(c)}catch(c){throw c===a.ended?(b.cursor--,b.offset--,c):c}}function g(c){let a=0,b=0;return c.forEach(function(c){a+=c*Math.pow(2,b),b+=8}),a}function A(d){const a=BigInt(0),e=BigInt(8);let b=a,c=a;return d.forEach(function(a){b+=BigInt(a)<<c,c+=e}),b}function y(a,c,b){try{return new TextDecoder("utf-8").decode(a.subarray(c,b))}catch(f){let d=c,e="";while(d<b){let c;if(a[d]===0)break;if((a[d]&128)===0)e+=String.fromCharCode(a[d++]);else if((a[d]&224)===192&&d+1<b)c=(a[d++]&31)<<6|a[d++]&63,e+=String.fromCharCode(c);else if((a[d]&240)===224&&d+2<b)c=(a[d++]&15)<<12|(a[d++]&63)<<6|a[d++]&63,e+=String.fromCharCode(c);else if((a[d]&248)===240&&d+3<b)if(c=(a[d++]&7)<<18|(a[d++]&63)<<12|(a[d++]&63)<<6|a[d++]&63,c>65535){c-=65536;const a=c>>>10&1023|55296,b=c&1023|56320;e+=String.fromCharCode(a,b)}else e+=String.fromCharCode(c);else break}return e}}function G(a){let b;if(a===void 0)a={};else if(typeof a!="object")throw new TypeError("The options parameter must be an object.");if(a.hasOwnProperty("maxlength")===!1)b=1073741824;else if(typeof a.maxlength=="number"&&a.maxlength>0)b=a.maxlength;else throw new RangeError("The maxlength option must be a positive integer.");const c=p(b),d=new WritableStream(c);return c.stream=d,d}function H(b,a){let c;if(a===void 0)a={};else if(typeof a!="object")throw new TypeError("The options parameter must be an object.");if(a.hasOwnProperty("maxlength")===!1)c=1073741824;else if(typeof a.maxlength=="number"&&a.maxlength>0)c=a.maxlength;else throw new RangeError("The maxlength option must be a positive integer.");if(typeof b=="object"){if(b[Symbol.asyncIterator]!==void 0){const d=b[Symbol.asyncIterator](),a=p(c);return a.start(),new Promise(function(e,b){d.next().then(c).catch(b);function c(f){f.done===!1?(a.write(f.value),d.next().then(c).catch(b)):e(a.close())}})}if(b.constructor.name==="ReadableStream"){const d=b.getReader(),a=p(c);return a.start(),new Promise(function(e,b){d.read().then(c).catch(b);function c(f){f.done===!1?(a.write(f.value),d.read().then(c).catch(b)):e(a.close())}})}throw new TypeError("The readable parameter must be a readable stream or async iterable.")}else throw new TypeError("The readable parameter must be a readable stream or async iterable.")}function p(l){const b={},c=[{}],f=Symbol(),h=Symbol(),e=Symbol(),i=Symbol(),k=Symbol(),s=Symbol();return{start:m,close:n,write:p};function m(a){b.map=new Map,b.bytes=new Uint8Array(0),b.cursor=0,b.offset=0,b.length=0,b.method="stream",Object.defineProperty(c[0],h,{configurable:!0,value:1}),Object.defineProperty(c[0],f,{configurable:!0,writable:!0,value:0}),Object.defineProperty(c[0],e,{configurable:!0,writable:!0,value:"root"})}function n(d){if(b.bytes.length>0)if(d!==void 0)d.error(a.unused);else throw a.unused;else{const a=c[0].root;if(delete c[0].root,this.stream!==void 0)this.stream.result=a,delete this.stream;else return a}}function p(n,p){let m;if((b.length+=n.length)<=l){b.bytes=q([b.bytes,n]);const p=b.bytes.length;let l=c.length-1;while(l>=0){const q=c[l],n=t(q);if(n===a.property)try{if(b.cursor+1>p)break;let g=d(b);if(g!==a.hole){{if(j(q,g),l===0)break;if(c.pop(),c[l-1][e]===k){if(c[l-1].has(n))throw a.malformed;c[l-1][e]=g}}}else if(q[i]==="A")q[f]++,c.pop();else throw a.malformed}catch(c){if(c===a.collection){{let a=b.cursor;const c=b.bytes[a++];if(c>>5===4){let d;const i=(c&7)+1;if(a+i>p)break;const k=g(b.bytes.subarray(a,a+=i));switch(c>>3&3){case 0:d=[];break;case 1:d={};break;case 2:d=new Map;break;case 3:d=new Set;break}Object.defineProperty(d,h,{configurable:!0,value:k}),Object.defineProperty(d,f,{configurable:!0,writable:!0,value:0}),Object.defineProperty(d,e,{configurable:!0,writable:!0,value:void 0}),j(q,d),b.map.set(b.offset,d),b.cursor+=i+1,b.offset+=i+1}else if(c>>5===5){const k=(c>>2&3)+1;if(a+k>p)break;const m=g(b.bytes.subarray(a,a+=k)),d=new Array(m),l=(c&3)+1;if(a+l>p)break;const n=g(b.bytes.subarray(a,a+=l));Object.defineProperty(d,h,{configurable:!0,value:n}),Object.defineProperty(d,f,{configurable:!0,writable:!0,value:0}),Object.defineProperty(d,e,{configurable:!0,writable:!0,value:void 0}),Object.defineProperty(d,i,{configurable:!0,value:(c>>4&1)===0?"A":"B"}),j(q,d),b.map.set(b.offset,d),b.cursor+=k+l+1,b.offset+=k+l+1}}}else{c!==a.ended&&(m=c);break}}else if(n[f]<n[h]){const g=n.constructor.name;if(g==="Array")if(n[i]!=="B")n[e]=n[f],c.push(n);else try{if(r(b)===!1)throw a.malformed;const f=d(b);if(f>=n.length)throw a.malformed;if(n.hasOwnProperty(f))throw a.malformed;n[e]=f,c.push(n)}catch(b){b!==a.ended&&(m=b);break}else if(g==="Object")try{if(o(b)===!1)throw a.malformed;const f=d(b);if(n.hasOwnProperty(f))throw a.malformed;n[e]=f,c.push(n)}catch(b){b!==a.ended&&(m=b);break}else if(g==="Map"){n[e]=k,c.push(n);const a={};Object.defineProperty(a,h,{configurable:!0,value:1}),Object.defineProperty(a,f,{configurable:!0,writable:!0,value:0}),Object.defineProperty(a,e,{configurable:!0,writable:!1,value:"root"}),c.push(a)}else g==="Set"&&(n[e]=s,c.push(n))}else{if(delete n[i],delete n[e],delete n[f],delete n[h],l===0)break;if(c.pop(),c[l-1][e]===k){if(c[l-1].has(n))throw a.malformed;c[l-1][e]=n}}l=c.length-1}m===void 0&&(b.bytes=b.bytes.slice(b.cursor),b.cursor=0)}else m=a.exceeded;if(m!==void 0)if(p!==void 0)p.error(m);else throw m}function j(b,c){const d=b.constructor.name;if(d==="Array")b.hasOwnProperty(i)?(b[b[e]]=c,b[f]++):(b.push(c),b[f]++);else if(d==="Object")b[b[e]]=c,b[f]++;else if(d==="Map")b.set(b[e],c),b[f]++;else if(d==="Set"){if(b.has(c))throw a.malformed;b.add(c),b[e]=c,b[f]++}}function t(b){const c=b[e],d=b.constructor.name;if(d==="Array"||d==="Object")return b.hasOwnProperty(c)?b[c]:a.property;if(d==="Map")return b.has(c)?b.get(c):a.property;if(d==="Set")return b.has(c)?c:a.property}}function J(){const a=new ArrayBuffer(2),b=new Uint16Array(a);b[0]=65279;const c=new Uint8Array(a);return c[0]===254?"BE":"LE"}function b(a,b){a.bytes.push(b),a.length+=b.length}function q(b,c){let a=0,d=0;c===void 0?b.forEach(function(b){a+=b.length}):a=c;const e=new Uint8Array(a);return b.forEach(function(a){e.set(a,d),d+=a.length}),e}function u(g){let c=0,d=0,e=0,f=0,a=-1;g.forEach(function(g,b){a=b,b<=65535?b<=255?c++:d++:b<=1677215?e++:f++}),a+=1;const b=c+d+e+f;if(b===g.length)return{};const h=a-b,i=2*c+3*d+4*e+5*f;return h<=i?{nslot:a}:{nelement:b}}function n(b){const a=new Uint8Array(b);for(let b=0,c=a.length;b<c;b+=2){const d=a[b];a[b]=a[b+1],a[b+1]=d}return b}function j(b){const a=new Uint8Array(b);for(let b=0,c=a.length;b<c;b+=4)for(let c=0;c<2;c+=1){const d=a[b+c];a[b+c]=a[b+3-c],a[b+3-c]=d}return b}function m(b){const a=new Uint8Array(b);for(let b=0,c=a.length;b<c;b+=8)for(let c=0;c<4;c+=1){const d=a[b+c];a[b+c]=a[b+7-c],a[b+7-c]=d}return b}function r(c){const b=c.bytes[c.cursor];if(b===void 0)throw a.ended;return b>>5===1&&(b>>4&1)===0&&(b>>3&1)===0}function h(b){const c=b.bytes[b.cursor];if(c===void 0)throw a.ended;return c===12}function o(c){const b=c.bytes[c.cursor];if(b===void 0)throw a.ended;return b>>5===3&&(b>>3&3)===0}function T(c){const b=c.bytes[c.cursor];if(b===void 0)throw a.ended;return b>>5===3&&(b>>3&3)>=2}function K(c){const b=c.bytes[c.cursor];if(b===void 0)throw a.ended;return b>>5===1&&(b>>4&1)===0||b===10}}()