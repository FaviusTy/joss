// Copyright (c) 2021 Tee Teik Wynn
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
"use strict";const endian=getEndianness(),encoders={Object:encodeCollect,Array:encodeCollect,Map:encodeCollect,Set:encodeCollect,DataView:encodeTypedArray,Int8Array:encodeTypedArray,Uint8Array:encodeTypedArray,Uint8ClampedArray:encodeTypedArray,Int16Array:encodeTypedArray,Uint16Array:encodeTypedArray,Int32Array:encodeTypedArray,Uint32Array:encodeTypedArray,Float32Array:encodeTypedArray,Float64Array:encodeTypedArray,BigInt64Array:encodeTypedArray,BigUint64Array:encodeTypedArray,Date:encodeDate,RegExp:encodeRegExp,ArrayBuffer:encodeString,SharedArrayBuffer:encodeString,Boolean:encodeBoolean,Number:encodeNumber,BigInt:encodeBigInt,String:encodeString},errors={hole:new Error("Encountered a hole in a sparse array"),ended:new Error("The serialized bytestream ended before the deserialization could complete successfully."),unused:new Error("The deserialization completed before the end of the serialized bytestream."),exceeded:new Error("The serialized bytestream exceeded the maximum acceptable length."),malformed:new Error("The serialized bytestream contained malformed byte sequences."),property:new Error("Encountered an undefined property of a collection."),collection:new Error("Encountered a collection in streaming mode.")};errors.ended.name="ERR_ENDED",errors.unused.name="ERR_UNUSED",errors.exceeded.name="ERR_EXCEEDED",errors.malformed.name="ERR_MALFORMED";export{encodeStatic as serialize,decodeStatic as deserialize,encodeStream as serializable,decodeStream as deserializable,decodeAsync as deserializing};function encodeStatic(e,r){const t={};if(void 0===r)r={};else if("object"!=typeof r)throw new TypeError("The options parameter must be an object.");if(!1===r.hasOwnProperty("endian"))t.endian=endian;else{if("LE"!==r.endian&&"BE"!==r.endian)throw new RangeError('The endian option must be either "LE" or "BE".');t.endian=r.endian}return t.bytes=[],t.length=0,t.record=new Map,t.method="static",encodeData(t,e),concatBytes(t.bytes,t.length)}function encodeData(e,r){switch(typeof r){case"object":if(null!==r){const t=r.constructor.name,n=encoders[t];return void 0!==n?!1===e.record.has(r)?(e.record.set(r,e.length),n(e,r,t)):encodeReference(e,r):appendBytes(e,Uint8Array.of(13))}return appendBytes(e,Uint8Array.of(0));case"undefined":return appendBytes(e,Uint8Array.of(1));case"boolean":return encodeBoolean(e,r);case"number":return encodeNumber(e,r);case"bigint":return encodeBigInt(e,r);case"string":return encodeString(e,r);default:appendBytes(e,Uint8Array.of(13))}}function encodeBoolean(e,r,t){void 0===t?appendBytes(e,!0===r?Uint8Array.of(2):Uint8Array.of(4)):!0===r.valueOf()?appendBytes(e,Uint8Array.of(3)):appendBytes(e,Uint8Array.of(5))}function encodeNumber(e,r,t){let n,o,a;if(n=32,void 0===t){if(a=r,!isFinite(a))return appendBytes(e,a===1/0?Uint8Array.of(6):a===-1/0?Uint8Array.of(8):Uint8Array.of(10))}else{if(a=r.valueOf(),!isFinite(a))return appendBytes(e,a===1/0?Uint8Array.of(7):a===-1/0?Uint8Array.of(9):Uint8Array.of(11));n|=16}Math.floor(a)===a&&Math.abs(a)<=Number.MAX_SAFE_INTEGER?((a<0||0===a&&1/a==-1/0)&&(n|=8),o=encodeUInt(Math.abs(a))):(o=new Uint8Array(new ArrayBuffer(8)),new DataView(o.buffer,o.byteOffset,o.byteOffset+o.length).setFloat64(0,a,!0)),appendBytes(e,Uint8Array.of(n|o.length-1)),appendBytes(e,o)}function encodeBigInt(e,r,t){let n,o,a;n=64,void 0===t?a=r:(a=r.valueOf(),n|=16),a>=0?o=encodeBigUInt(a):(n|=8,o=encodeBigUInt(-a));const s=encodeUInt(o.length);appendBytes(e,Uint8Array.of(n|s.length-1)),appendBytes(e,s),appendBytes(e,o)}function encodeString(e,r,t,n,o){let a,s;a=96,void 0===t?s=encodeUTF8(r):"String"===t?(a|=8,s=encodeUTF8(r.valueOf())):(a|="ArrayBuffer"===t?16:24,s=new Uint8Array(r,n||0,o||r.byteLength));const c=encodeUInt(s.length);appendBytes(e,Uint8Array.of(a|c.length-1)),appendBytes(e,c),appendBytes(e,s)}function encodeCollect(e,r,t){if("stream"===e.method)throw errors.collection;let n;if(n=128,"Array"===t){const t=encodeUInt(r.length),o=analyzeArray(r);if(void 0!==o.nslot){n=160;const a=o.nslot,s=encodeUInt(a);appendBytes(e,Uint8Array.of(0|n|t.length-1<<2|s.length-1)),appendBytes(e,t),appendBytes(e,s);for(let t=0;t<a;t+=1)r.hasOwnProperty(t)?encodeData(e,r[t]):appendBytes(e,Uint8Array.of(12))}else if(void 0!==o.nelement){n=160;const a=encodeUInt(o.nelement);appendBytes(e,Uint8Array.of(16|n|t.length-1<<2|a.length-1)),appendBytes(e,t),appendBytes(e,a),r.forEach((function(r,t){encodeData(e,t),encodeData(e,r)}))}else{encodeUInt(r.length);appendBytes(e,Uint8Array.of(n|t.length-1)),appendBytes(e,t),r.forEach((function(r){encodeData(e,r)}))}}else if("Object"===t){const t=encodeUInt(Object.keys(r).length);appendBytes(e,Uint8Array.of(8|n|t.length-1)),appendBytes(e,t);for(let t in r)r.hasOwnProperty(t)&&(encodeData(e,t),encodeData(e,r[t]))}else if("Map"===t){const t=encodeUInt(r.size);appendBytes(e,Uint8Array.of(16|n|t.length-1)),appendBytes(e,t),r.forEach((function(r,t){encodeData(e,t),encodeData(e,r)}))}else{const t=encodeUInt(r.size);appendBytes(e,Uint8Array.of(24|n|t.length-1)),appendBytes(e,t),r.forEach((function(r){encodeData(e,r)}))}}function encodeTypedArray(e,r,t){let n,o,a,s;if(n=192,"BE"===e.endian&&(n|=16),e.endian!==endian&&r.BYTES_PER_ELEMENT>1){switch(o=r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength),r.BYTES_PER_ELEMENT){case 2:o=swap16(o);break;case 4:o=swap32(o);break;case 8:o=swap64(o)}a=0,s=o.byteLength}else o=r.buffer,a=r.byteOffset,s=r.byteLength;appendBytes(e,Uint8Array.of(n|["DataView","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"].indexOf(t))),!1===e.record.has(o)?(e.record.set(o,e.length),encodeString(e,o,o.constructor.name,a,s)):encodeReference(e,o)}function encodeDate(e,r){appendBytes(e,Uint8Array.of(14)),encodeData(e,r.valueOf())}function encodeRegExp(e,r){appendBytes(e,Uint8Array.of(15)),encodeData(e,r.toString())}function encodeReference(e,r){appendBytes(e,Uint8Array.of(29)),encodeNumber(e,e.record.get(r))}function encodeUInt(e){const r=[];for(;e>255;)r.push(255&e),e=Math.floor(e/256);return r.push(e),Uint8Array.from(r)}function encodeBigUInt(e){const r=[],t=BigInt(8),n=BigInt(255);for(;e>n;)r.push(Number(e&n)),e>>=t;return r.push(Number(e)),Uint8Array.from(r)}function encodeUTF8(e){try{return(new TextEncoder).encode(e)}catch(r){let t=0;const n=[],o=e.length;for(;t<o;){let r=e.charCodeAt(t++);if(r<=127)n.push(r);else if(r<=2047)n.push(r>>6&31|192),n.push(63&r|128);else if(r<=55295||r>=57344&&r<=65535)n.push(r>>12&15|224),n.push(r>>6&63|128),n.push(63&r|128);else{const o=r,a=e.charCodeAt(t++);if(o<55296||o>56319)continue;if(a<56320||a>57343)continue;r=(1023&o)<<10|1023&a,r+=65536,n.push(r>>18&7|240),n.push(r>>12&63|128),n.push(r>>6&63|128),n.push(63&r|128)}}return Uint8Array.from(n)}}function encodeStream(e,r){const t={};if(void 0===r)r={};else if("object"!=typeof r)throw new TypeError("The options parameter must be an object.");if(!1===r.hasOwnProperty("endian"))t.endian=endian;else{if("LE"!==r.endian&&"BE"!==r.endian)throw new RangeError('The endian option must be either "LE" or "BE".');t.endian=r.endian}t.length=0,t.record=new Map,t.method="stream";const n=[],o=[],a=[],s=Symbol(),c=Symbol(),i=Symbol();return new ReadableStream({start:function(r){n.push(0),o.push({root:e}),a.push(d(o[0]))},pull:function(e){const r=o.length-1;if(r>=0){t.bytes=[];const f=n[r],l=o[r],y=a[r].next();if(0===f){let e;e=128;const n=l.constructor.name;if("Array"===n){const r=encodeUInt(l.length);if(l.hasOwnProperty(c)){e=160;const n=encodeUInt(l[c]);appendBytes(t,Uint8Array.of(0|e|r.length-1<<2|n.length-1)),appendBytes(t,r),appendBytes(t,n)}else if(l.hasOwnProperty(i)){e=160;const n=encodeUInt(l[i]);appendBytes(t,Uint8Array.of(16|e|r.length-1<<2|n.length-1)),appendBytes(t,r),appendBytes(t,n)}else{encodeUInt(l.length);appendBytes(t,Uint8Array.of(e|r.length-1)),appendBytes(t,r)}}else if("Object"===n&&0!==r){const r=encodeUInt(l[s]);appendBytes(t,Uint8Array.of(8|e|r.length-1)),appendBytes(t,r)}else if("Map"===n){const r=encodeUInt(l.size);appendBytes(t,Uint8Array.of(16|e|r.length-1)),appendBytes(t,r)}else if("Set"===n){const r=encodeUInt(l.size);appendBytes(t,Uint8Array.of(24|e|r.length-1)),appendBytes(t,r)}}if(!1===y.done){if(2!==f){const e=y.value,s=l.constructor.name;if("Array"===s&&l.hasOwnProperty(i))encodeData(t,e);else if("Object"===s&&0!==r)encodeData(t,e);else if("Map"===s)try{encodeData(t,e)}catch(r){if(r!==errors.collection)throw r;n.push(0),o.push(e),a.push(d(e))}n[r]=2}else if(2===f){const e=y.value;if(e!==errors.hole)try{encodeData(t,e)}catch(r){if(r!==errors.collection)throw r;n.push(0),o.push(e),a.push(d(e))}else l.hasOwnProperty(c)&&appendBytes(t,Uint8Array.of(12));n[r]=1}}else delete l[i],delete l[c],delete l[s],n.pop(),o.pop(),a.pop();0!==t.bytes.length?e.enqueue(concatBytes(t.bytes)):this.pull(e)}else e.close()}});function d(e){let r,t,n,o;t="key";const a=e.constructor.name;if("Array"===a){o=e.keys();const r=analyzeArray(e);void 0!==r.nslot?Object.defineProperty(e,c,{configurable:!0,value:r.nslot}):void 0!==r.nelement&&Object.defineProperty(e,i,{configurable:!0,value:r.nelement})}else"Object"===a?(o=Object.keys(e),Object.defineProperty(e,s,{configurable:!0,value:o.length}),n=-1):"Map"!==a&&"Set"!==a||(o=e.keys());return{next:function(){if("key"===t){if(t="value",void 0===n){let t=o.next();if(e.hasOwnProperty(i))for(;!1===e.hasOwnProperty(t.value)&&!1===t.done;)t=o.next();return!1===t.done?(r=t.value,e.hasOwnProperty(c)&&r>=e[c]?{value:void 0,done:!0}:{value:r,done:!1}):{value:void 0,done:!0}}return n+=1,void 0!==o[n]?(r=o[n],{value:r,done:!1}):{value:void 0,done:!0}}if(t="key","Array"===a)return e.hasOwnProperty(r)?{value:e[r],done:!1}:{value:errors.hole,done:!1};if("Object"===a)return{value:e[r],done:!1};if("Map"===a)return{value:e.get(r),done:!1};if("Set"===a)return{value:r,done:!1}}}}}function decodeStatic(e){if("object"!=typeof e||"Uint8Array"!==e.constructor.name)throw new TypeError("The bytes parameter must be a Uint8Array.");const r={};r.map=new Map,r.bytes=e,r.cursor=0,r.offset=0,r.method="static";const t=decodeData(r);if(r.cursor!==r.bytes.length)throw errors.unused;return t}function decodeData(e){const r=e.bytes[e.cursor];if(void 0===r)throw errors.ended;if(r<=13){let t;switch(e.cursor++,e.offset++,r){case 0:return null;case 1:return;case 2:return!0;case 3:t=new Boolean(!0);break;case 4:return!1;case 5:t=new Boolean(!1);break;case 6:return 1/0;case 7:t=new Number(1/0);break;case 8:return-1/0;case 9:t=new Number(-1/0);break;case 10:return NaN;case 11:t=new Number(NaN);break;case 12:return errors.hole;case 13:return new ReferenceError}return e.map.set(e.offset-1,t),t}if(r<=31)switch(r){case 14:return decodeDate(e);case 15:return decodeRegExp(e);case 29:return decodeReference(e);default:throw errors.malformed}else switch(r>>5){case 1:return decodeNumber(e);case 2:return decodeBigInt(e);case 3:return decodeString(e);case 4:return decodeCollect(e);case 5:return decodeSparseArray(e);case 6:return decodeTypedArray(e);case 7:throw errors.malformed}}function decodeNumber(e){let r,t=e.cursor;const n=e.bytes[t++],o=1+(7&n);if(t+o>e.bytes.length)throw errors.ended;if(o<8){if(7===o&&e.bytes[t+6]>31)throw errors.malformed;r=decodeUInt(e.bytes.subarray(t,t+=o)),1==(n>>3&1)&&(r*=-1)}else{const n=e.bytes.subarray(t,t+=o);r=new DataView(n.buffer,n.byteOffset,n.length).getFloat64(0,!0)}return 1==(n>>4&1)&&(r=new Number(r),e.map.set(e.offset,r)),e.cursor+=o+1,e.offset+=o+1,r}function decodeBigInt(e){let r,t=e.cursor;const n=e.bytes[t++],o=1+(7&n);if(t+o>e.bytes.length)throw errors.ended;const a=decodeUInt(e.bytes.subarray(t,t+=o));if(t+a>e.bytes.length)throw errors.ended;return r=decodeBigUInt(e.bytes.subarray(t,t+=a)),1==(n>>3&1)&&(r*=BigInt(-1)),1==(n>>4&1)&&(r=new Object(r),e.map.set(e.offset,r)),e.cursor+=o+a+1,e.offset+=o+a+1,r}function decodeString(e){let r,t=e.cursor;const n=e.bytes[t++],o=1+(7&n);if(t+o>e.bytes.length)throw errors.ended;const a=decodeUInt(e.bytes.subarray(t,t+=o));if(t+a>e.bytes.length)throw errors.ended;switch(n>>3&3){case 0:r=decodeUTF8(e.bytes,t,t+=a);break;case 1:r=new String(decodeUTF8(e.bytes,t,t+=a)),e.map.set(e.offset,r);break;case 2:r=new ArrayBuffer(a),e.map.set(e.offset,r),new Uint8Array(r).set(e.bytes.subarray(t,t+=a));break;case 3:r=new SharedArrayBuffer(a),e.map.set(e.offset,r),new Uint8Array(r).set(e.bytes.subarray(t,t+=a))}return e.cursor+=o+a+1,e.offset+=o+a+1,r}function decodeCollect(e){if("stream"===e.method)throw errors.collection;let r,t=e.cursor;const n=e.bytes[t++],o=1+(7&n);if(t+o>e.bytes.length)throw errors.ended;const a=decodeUInt(e.bytes.subarray(t,t+=o));switch(n>>3&3){case 0:r=[],e.map.set(e.offset,r),e.cursor+=o+1,e.offset+=o+1;for(let t=0;t<a;t+=1)r.push(decodeData(e));return r;case 1:r={},e.map.set(e.offset,r),e.cursor+=o+1,e.offset+=o+1;for(let t=0;t<a;t+=1){if(!1===isStringByte(e))throw errors.malformed;r[decodeData(e)]=decodeData(e)}return r;case 2:r=new Map,e.map.set(e.offset,r),e.cursor+=o+1,e.offset+=o+1;for(let t=0;t<a;t+=1)r.set(decodeData(e),decodeData(e));return r;case 3:r=new Set,e.map.set(e.offset,r),e.cursor+=o+1,e.offset+=o+1;for(let t=0;t<a;t+=1)r.add(decodeData(e));return r}}function decodeSparseArray(e){if("stream"===e.method)throw errors.collection;let r=e.cursor;const t=e.bytes[r++],n=e.bytes.length,o=1+(t>>2&3);if(r+o>n)throw errors.ended;const a=decodeUInt(e.bytes.subarray(r,r+=o)),s=new Array(a),c=1+(3&t);if(r+c>n)throw errors.ended;const i=decodeUInt(e.bytes.subarray(r,r+=c));if(e.map.set(e.offset,s),e.cursor+=o+c+1,e.offset+=o+c+1,0==(t>>4&1)){for(let r=0;r<i;r+=1){const t=decodeData(e);t!==errors.hole&&(s[r]=t)}return s}for(let r=0;r<i;r+=1){if(!1===isNaturalByte(e))throw errors.malformed;s[decodeData(e)]=decodeData(e)}return s}function decodeTypedArray(e){const r=e.offset,t=e.bytes[e.cursor],n=endian!==(t>>4&1?"BE":"LE"),o=15&t;e.cursor++,e.offset++;try{let t;if(!1===isBufferByte(e))throw errors.malformed;const a=decodeData(e);switch(o){case 0:t=new DataView(a);break;case 1:t=new Int8Array(a);break;case 2:t=new Uint8Array(a);break;case 3:t=new Uint8ClampedArray(a);break;case 4:t=n?new Int16Array(swap16(a.slice())):new Int16Array(a);break;case 5:t=n?new Uint16Array(swap16(a.slice())):new Uint16Array(a);break;case 6:t=n?new Int32Array(swap32(a.slice())):new Int32Array(a);break;case 7:t=n?new Uint32Array(swap32(a.slice())):new Uint32Array(a);break;case 8:t=n?new Float32Array(swap32(a.slice())):new Float32Array(a);break;case 9:t=n?new Float64Array(swap64(a.slice())):new Float64Array(a);break;case 10:t=n?new BigInt64Array(swap64(a.slice())):new BigInt64Array(a);break;case 11:t=n?new BigUint64Array(swap64(a.slice())):new BigUint64Array(a);break;default:throw errors.malformed}return e.map.set(r,t),t}catch(r){throw r===errors.ended?(e.cursor--,e.offset--,r):r}}function decodeDate(e){const r=e.offset;e.cursor++,e.offset++;try{if(!1===isDateByte(e))throw errors.malformed;const t=new Date(decodeData(e));return e.map.set(r,t),t}catch(r){throw r===errors.ended?(e.cursor--,e.offset--,r):r}}function decodeRegExp(e){const r=e.offset;e.cursor++,e.offset++;try{if(!1===isStringByte(e))throw errors.malformed;const t=decodeData(e),n=t.lastIndexOf("/");if("/"!==t[0]||n<=0)throw errors.malformed;const o=new RegExp(t.slice(1,n),t.slice(n+1));return e.map.set(r,o),o}catch(r){throw r===errors.ended?(e.cursor--,e.offset--,r):r}}function decodeReference(e){e.cursor++,e.offset++;try{if(!1===isNaturalByte(e))throw errors.malformed;const r=decodeData(e);if(!1===e.map.has(r))throw errors.malformed;return e.map.get(r)}catch(r){throw r===errors.ended?(e.cursor--,e.offset--,r):r}}function decodeUInt(e){let r=0,t=0;return e.forEach((function(e){r+=e*Math.pow(2,t),t+=8})),r}function decodeBigUInt(e){const r=BigInt(0),t=BigInt(8);let n=r,o=r;return e.forEach((function(e){n+=BigInt(e)<<o,o+=t})),n}function decodeUTF8(e,r,t){try{return new TextDecoder("utf-8").decode(e.subarray(r,t))}catch(n){let o=r,a="";for(;o<t;){let r;if(0===e[o])break;if(0==(128&e[o]))a+=String.fromCharCode(e[o++]);else if(192==(224&e[o])&&o+1<t)r=(31&e[o++])<<6|63&e[o++],a+=String.fromCharCode(r);else if(224==(240&e[o])&&o+2<t)r=(15&e[o++])<<12|(63&e[o++])<<6|63&e[o++],a+=String.fromCharCode(r);else{if(!(240==(248&e[o])&&o+3<t))break;if(r=(7&e[o++])<<18|(63&e[o++])<<12|(63&e[o++])<<6|63&e[o++],r>65535){r-=65536;const e=r>>>10&1023|55296,t=1023&r|56320;a+=String.fromCharCode(e,t)}else a+=String.fromCharCode(r)}}return a}}function decodeStream(e){let r;if(void 0===e)e={};else if("object"!=typeof e)throw new TypeError("The options parameter must be an object.");if(!1===e.hasOwnProperty("maxlength"))r=1073741824;else{if(!("number"==typeof e.maxlength&&e.maxlength>0))throw new RangeError("The maxlength option must be a positive integer.");r=e.maxlength}const t=decoder(r),n=new WritableStream(t);return t.stream=n,n}function decodeAsync(e,r){let t;if(void 0===r)r={};else if("object"!=typeof r)throw new TypeError("The options parameter must be an object.");if(!1===r.hasOwnProperty("maxlength"))t=1073741824;else{if(!("number"==typeof r.maxlength&&r.maxlength>0))throw new RangeError("The maxlength option must be a positive integer.");t=r.maxlength}if("object"==typeof e){if(void 0!==e[Symbol.asyncIterator]){const r=e[Symbol.asyncIterator](),n=decoder(t);return n.start(),new Promise((function(e,t){r.next().then((function o(a){!1===a.done?(n.write(a.value),r.next().then(o).catch(t)):e(n.close())})).catch(t)}))}if("ReadableStream"===e.constructor.name){const r=e.getReader(),n=decoder(t);return n.start(),new Promise((function(e,t){r.read().then((function o(a){!1===a.done?(n.write(a.value),r.read().then(o).catch(t)):e(n.close())})).catch(t)}))}throw new TypeError("The readable parameter must be a readable stream or async iterable.")}throw new TypeError("The readable parameter must be a readable stream or async iterable.")}function decoder(e){const r={},t=[{}],n=Symbol(),o=Symbol(),a=Symbol(),s=Symbol(),c=Symbol(),i=Symbol();return{start:function(e){r.map=new Map,r.bytes=new Uint8Array(0),r.cursor=0,r.offset=0,r.length=0,r.method="stream",Object.defineProperty(t[0],o,{configurable:!0,value:1}),Object.defineProperty(t[0],n,{configurable:!0,writable:!0,value:0}),Object.defineProperty(t[0],a,{configurable:!0,writable:!0,value:"root"})},close:function(e){if(r.bytes.length>0){if(void 0===e)throw errors.unused;e.error(errors.unused)}else{const e=t[0].root;if(delete t[0].root,void 0===this.stream)return e;this.stream.result=e,delete this.stream}},write:function(l,y){let u;if((r.length+=l.length)<=e){r.bytes=concatBytes([r.bytes,l]);const e=r.bytes.length;let y=t.length-1;for(;y>=0;){const l=t[y],p=f(l);if(p===errors.property)try{if(r.cursor+1>e)break;let o=decodeData(r);if(o!==errors.hole){if(d(l,o),0===y)break;t.pop(),t[y-1][a]===c&&(t[y-1][a]=o)}else{if("A"!==l[s])throw errors.malformed;l[n]++,t.pop()}}catch(t){if(t!==errors.collection){t!==errors.ended&&(u=t);break}{let t=r.cursor;const c=r.bytes[t++];if(c>>5==4){let s;const i=1+(7&c);if(t+i>e)break;const f=decodeUInt(r.bytes.subarray(t,t+=i));switch(c>>3&3){case 0:s=[];break;case 1:s={};break;case 2:s=new Map;break;case 3:s=new Set}Object.defineProperty(s,o,{configurable:!0,value:f}),Object.defineProperty(s,n,{configurable:!0,writable:!0,value:0}),Object.defineProperty(s,a,{configurable:!0,writable:!0,value:void 0}),d(l,s),r.map.set(r.offset,s),r.cursor+=i+1,r.offset+=i+1}else if(c>>5==5){const i=1+(c>>2&3);if(t+i>e)break;const f=decodeUInt(r.bytes.subarray(t,t+=i)),y=new Array(f),u=1+(3&c);if(t+u>e)break;const p=decodeUInt(r.bytes.subarray(t,t+=u));Object.defineProperty(y,o,{configurable:!0,value:p}),Object.defineProperty(y,n,{configurable:!0,writable:!0,value:0}),Object.defineProperty(y,a,{configurable:!0,writable:!0,value:void 0}),Object.defineProperty(y,s,{configurable:!0,value:0==(c>>4&1)?"A":"B"}),d(l,y),r.map.set(r.offset,y),r.cursor+=i+u+1,r.offset+=i+u+1}}}else if(p[n]<p[o]){const e=p.constructor.name;if("Array"===e)if("B"!==p[s])p[a]=p[n],t.push(p);else try{if(!1===isNaturalByte(r))throw errors.malformed;p[a]=decodeData(r),t.push(p)}catch(e){e!==errors.ended&&(u=e);break}else if("Object"===e)try{if(!1===isStringByte(r))throw errors.malformed;p[a]=decodeData(r),t.push(p)}catch(e){e!==errors.ended&&(u=e);break}else if("Map"===e){p[a]=c,t.push(p);const e={};Object.defineProperty(e,o,{configurable:!0,value:1}),Object.defineProperty(e,n,{configurable:!0,writable:!0,value:0}),Object.defineProperty(e,a,{configurable:!0,writable:!1,value:"root"}),t.push(e)}else"Set"===e&&(p[a]=i,t.push(p))}else{if(delete p[s],delete p[a],delete p[n],delete p[o],0===y)break;t.pop(),t[y-1][a]===c&&(t[y-1][a]=p)}y=t.length-1}void 0===u&&(r.bytes=r.bytes.slice(r.cursor),r.cursor=0)}else u=errors.exceeded;if(void 0!==u){if(void 0===y)throw u;y.error(u)}}};function d(e,r){const t=e.constructor.name;"Array"===t?e.hasOwnProperty(s)?(e[e[a]]=r,e[n]++):(e.push(r),e[n]++):"Object"===t?(e[e[a]]=r,e[n]++):"Map"===t?(e.set(e[a],r),e[n]++):"Set"===t&&(e.add(r),e[a]=r,e[n]++)}function f(e){const r=e[a],t=e.constructor.name;return"Array"===t||"Object"===t?e.hasOwnProperty(r)?e[r]:errors.property:"Map"===t?e.has(r)?e.get(r):errors.property:"Set"===t?e.has(r)?r:errors.property:void 0}}function getEndianness(){const e=new ArrayBuffer(2);new Uint16Array(e)[0]=65279;return 254===new Uint8Array(e)[0]?"BE":"LE"}function appendBytes(e,r){e.bytes.push(r),e.length+=r.length}function concatBytes(e,r){let t=0,n=0;void 0===r?e.forEach((function(e){t+=e.length})):t=r;const o=new Uint8Array(t);return e.forEach((function(e){o.set(e,n),n+=e.length})),o}function analyzeArray(e){let r=0,t=0,n=0,o=0,a=-1;e.forEach((function(e,s){a=s,s<=65535?s<=255?r++:t++:s<=1677215?n++:o++})),a+=1;const s=r+t+n+o;if(s===e.length)return{};return a-s<=2*r+3*t+4*n+5*o?{nslot:a}:{nelement:s}}function swap16(e){const r=new Uint8Array(e);for(let e=0,t=r.length;e<t;e+=2){const t=r[e];r[e]=r[e+1],r[e+1]=t}return e}function swap32(e){const r=new Uint8Array(e);for(let e=0,t=r.length;e<t;e+=4)for(let t=0;t<2;t+=1){const n=r[e+t];r[e+t]=r[e+3-t],r[e+3-t]=n}return e}function swap64(e){const r=new Uint8Array(e);for(let e=0,t=r.length;e<t;e+=8)for(let t=0;t<4;t+=1){const n=r[e+t];r[e+t]=r[e+7-t],r[e+7-t]=n}return e}function isNaturalByte(e){const r=e.bytes[e.cursor];if(void 0===r)throw errors.ended;return r>>5==1&&0==(r>>4&1)&&0==(r>>3&1)}function isStringByte(e){const r=e.bytes[e.cursor];if(void 0===r)throw errors.ended;return r>>5==3&&0==(r>>3&3)}function isBufferByte(e){const r=e.bytes[e.cursor];if(void 0===r)throw errors.ended;return r>>5==3&&(r>>3&3)>=2}function isDateByte(e){const r=e.bytes[e.cursor];if(void 0===r)throw errors.ended;return r>>5==1&&0==(r>>4&1)||10===r}